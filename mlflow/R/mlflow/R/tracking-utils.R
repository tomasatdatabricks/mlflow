mlflow_relative_paths <- function(paths) {
  gsub(paste0("^", file.path(getwd(), "")), "", paths)
}

get_executing_file_name <- function() {
  pattern <- "^--file="
  v <- grep(pattern, commandArgs(), value = TRUE)
  file_name <- gsub(pattern, "", v)
  if (length(file_name)) file_name
}

get_source_name <- function() {
  get_executing_file_name() %||% "<console>"
}

get_source_version <- function() {
  file_name <- get_executing_file_name()
  tryCatch(
    error = function(cnd) NULL,
    {
      repo <- git2r::repository(file_name, discover = TRUE)
      commit <- git2r::commits(repo, n = 1)
      commit[[1]]@sha
    }
  )
}

mlflow_get_or_start_run <- function() {
  mlflow_active_run() %||% mlflow_start_run()
}

#' @export
with.mlflow_run <- function(data, expr, ...) {

  tryCatch(
    {
      force(expr)
      mlflow_end_run()
    },
    error = function(cnd) {
      message(cnd)
      mlflow_end_run(status = "FAILED")
    },
    interrupt = function(cnd) mlflow_end_run(status = "KILLED")
  )

  invisible(NULL)
}


run_id <- function(run) cast_nullable_string(run$info$run_uuid)

active_run_id <- function() run_id(mlflow_active_run())

current_time <- function() {
  round(as.numeric(Sys.time()) * 1000)
}

milliseconds_to_date <- function(x) as.POSIXct(as.double(x) / 1000, origin = "1970-01-01")

tidy_run_info <- function(run_info) {
  df <- as.data.frame(run_info, stringsAsFactors = FALSE)
  df$start_time <- milliseconds_to_date(df$start_time %||% NA)
  df$end_time <- milliseconds_to_date(df$end_time %||% NA)
  df
}

wait_for <- function(f, wait, sleep) {
  command_start <- Sys.time()

  success <- FALSE
  while (!success && Sys.time() < command_start + wait) {
    success <- suppressWarnings({
      tryCatch({
        f()
        TRUE
      }, error = function(err) {
        FALSE
      })
    })

    if (!success) Sys.sleep(sleep)
  }

  if (!success) {
    stop("Operation failed after waiting for ", wait, " seconds")
  }
}

mlflow_user <- function() {
  if ("user" %in% names(Sys.info()))
    Sys.info()[["user"]]
  else
    "unknown"
}

mlflow_sourcetype_to_string <- function(source_type) {
   res <- names(MLFLOW_SOURCE_TYPE)[which(MLFLOW_SOURCE_TYPE == source_type)]
   if (length(res) != 1) {
     stop(paste("Indalid source type '", source_type, "'. Expected one of mlflow_source_types.",
                sep = ""))
   }
   res
}

MLFLOW_SOURCE_TYPE <- list(
  NOTEBOOK = 1,
  JOB = 2,
  PROJECT = 3,
  LOCAL = 4,
  UNKNOWN = 5
)

MLFLOW_TAGS = list(
  MLFLOW_RUN_NAME = "mlflow.runName",
  MLFLOW_PARENT_RUN_ID = "mlflow.parentRunId",
  MLFLOW_SOURCE_TYPE = "mlflow.source.type",
  MLFLOW_SOURCE_NAME = "mlflow.source.name",
  MLFLOW_GIT_COMMIT = "mlflow.source.git.commit",
  MLFLOW_GIT_BRANCH = "mlflow.source.git.branch",
  MLFLOW_GIT_REPO_URL = "mlflow.source.git.repoURL",
  MLFLOW_PROJECT_ENV = "mlflow.project.env",
  MLFLOW_PROJECT_ENTRY_POINT = "mlflow.project.entryPoint",
  MLFLOW_DOCKER_IMAGE_NAME = "mlflow.docker.image.name",
  MLFLOW_DOCKER_IMAGE_ID = "mlflow.docker.image.id"
)

#' @export
mlflow_source_type <- function() {
  list(MLFLOW_SOURCE_TYPE)
}

#' @export
mlflow_tag <- function() {
  list(MLFLOW_TAG)
}

